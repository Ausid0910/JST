<!DOCTYPE html>
<html lang="id">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Senter Pintar</title>
    <link rel="manifest" href="manifest.json" />
    <meta name="theme-color" content="#4ecca3" />
    <style>
      :root {
        --bg: #071028;
        --card: #0b1630;
        --accent: #1f6bff;
        --accent2: #13c6ff;
        --muted: #9bb2d1;
        --text: #eaf2ff;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
        background: linear-gradient(180deg, var(--bg), #03142c);
        color: var(--text);
        -webkit-font-smoothing: antialiased;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        padding: 16px;
      }
      .card {
        width: 100%;
        max-width: 920px;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.02),
          rgba(255, 255, 255, 0.01)
        );
        border-radius: 12px;
        padding: 16px;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6);
        border: 1px solid rgba(255, 255, 255, 0.03);
      }
      h1 {
        margin: 0 0 8px;
        color: var(--accent);
      }
      p.small {
        color: var(--muted);
        margin: 0 0 12px;
      }
      .layout {
        display: grid;
        grid-template-columns: 1fr 360px;
        gap: 12px;
      }
      @media (max-width: 900px) {
        .layout {
          grid-template-columns: 1fr;
        }
      }
      .panel {
        background: rgba(255, 255, 255, 0.01);
        padding: 12px;
        border-radius: 10px;
      }
      video {
        width: 100%;
        height: auto;
        border-radius: 8px;
        background: #000;
        display: block;
      }
      canvas {
        display: none;
      }
      .controls {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 10px;
      }
      .btn {
        background: linear-gradient(90deg, var(--accent), var(--accent2));
        color: #001;
        border: none;
        padding: 10px 12px;
        border-radius: 8px;
        font-weight: 700;
        cursor: pointer;
      }
      .btn.ghost {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.04);
        color: var(--text);
      }
      .status {
        margin-top: 8px;
        color: var(--muted);
        font-size: 13px;
      }
      .meters {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-top: 10px;
      }
      .meter {
        background: rgba(255, 255, 255, 0.02);
        padding: 8px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.02);
      }
      .meter label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 6px;
      }
      .bar {
        height: 14px;
        background: rgba(255, 255, 255, 0.04);
        border-radius: 8px;
        overflow: hidden;
      }
      .bar > i {
        display: block;
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, var(--accent), var(--accent2));
      }
      .small {
        font-size: 13px;
        color: var(--muted);
      }
      .log {
        background: #04112a;
        padding: 8px;
        border-radius: 8px;
        margin-top: 10px;
        color: #bfeaff;
        max-height: 160px;
        overflow: auto;
        font-size: 13px;
      }
      .overlay-torch {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(255, 255, 255, 0);
        pointer-events: none;
        transition: background 0.2s;
      }
      .overlay-torch.on {
        background: rgba(255, 255, 255, 0.98);
        pointer-events: none;
      }
      .overlay-text {
        position: fixed;
        bottom: 18px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.6);
        color: #fff;
        padding: 8px 12px;
        border-radius: 999px;
        font-weight: 700;
      }
      .switch {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      input[type="range"] {
        width: 100%;
      }
      .caption {
        font-size: 12px;
        color: var(--muted);
      }
    </style>
  </head>
  <body>
    <div class="card">
      <h1>Senter Pintar (Perceptron 2-input)</h1>
      <p class="small">
        Kondisi nyalakan senter: <strong>1) Gelap saja</strong> atau
        <strong>2) Gelap dan ada gerakan</strong>. Tekan
        <em>Aktifkan Mode Otomatis</em> dulu (user gesture) agar browser
        mengizinkan kontrol senter.
      </p>

      <div class="layout">
        <!-- Left: Camera + controls -->
        <div class="panel">
          <video id="video" autoplay playsinline muted></video>
          <canvas id="canvas"></canvas>

          <div class="controls">
            <button class="btn" id="startBtn">Mulai Kamera</button>
            <button class="btn ghost" id="stopBtn" disabled>Stop</button>
            <button class="btn" id="autoBtn" disabled>
              Aktifkan Mode Otomatis
            </button>
            <button class="btn ghost" id="manualTorchBtn" disabled>
              Toggle Senter Manual
            </button>
          </div>

          <div class="meters">
            <div class="meter">
              <label>Brightness (rata-rata)</label>
              <div class="bar"><i id="brightBar"></i></div>
              <div class="small">Nilai: <span id="brightVal">-</span></div>
            </div>
            <div class="meter">
              <label>Motion (level)</label>
              <div class="bar"><i id="motionBar"></i></div>
              <div class="small">Nilai: <span id="motionVal">-</span></div>
            </div>
          </div>

          <div style="display: flex; gap: 8px; margin-top: 10px">
            <div style="flex: 1">
              <label class="caption"
                >Ambang kegelapan (lebih kecil = lebih peka)</label
              >
              <input
                id="brightThresh"
                type="range"
                min="5"
                max="120"
                value="50"
              />
            </div>
            <div style="flex: 1">
              <label class="caption">Ambang gerakan (sensitivitas)</label>
              <input
                id="motionThresh"
                type="range"
                min="1"
                max="50"
                value="8"
              />
            </div>
          </div>

          <div class="status" id="status">Status: belum aktif</div>
          <div class="log" id="log"></div>
        </div>

        <!-- Right: Explanation & settings -->
        <div class="panel">
          <h3 style="margin-top: 0">Penjelasan & Pengaturan</h3>
          <p class="small">Cara kerja singkat (perceptron sederhana):</p>
          <ol style="padding-left: 18px">
            <li>
              Ambil dua input: <strong>isDark</strong> (1 jika gelap) dan
              <strong>hasMotion</strong> (1 jika terdeteksi gerak).
            </li>
            <li>
              Perceptron memutuskan apakah senter harus nyala. Syarat kita:
              <strong>senter nyala bila isDark = 1</strong> (mencakup kasus
              gerak juga).
            </li>
            <li>
              Browser biasanya menuntut <em>user gesture</em> (klik tombol)
              sebelum mengizinkan kontrol senter. Tekan
              <strong>Aktifkan Mode Otomatis</strong> untuk memberi izin awal.
            </li>
          </ol>

          <div style="margin-top: 10px">
            <label class="caption">Fallback:</label>
            <p class="small">
              Jika perangkat / browser tidak mendukung kontrol torch, aplikasi
              akan menyalakan <strong>simulasi senter layar</strong> (layar
              putih terang).
            </p>
          </div>

          <div style="margin-top: 12px">
            <label class="caption">Debug & kemampuan kamera</label>
            <div id="capabilities" class="small">Belum ada info</div>
          </div>

          <div style="margin-top: 12px">
            <strong>Petunjuk singkat:</strong>
            <ul class="small" style="padding-left: 18px">
              <li>
                Gunakan <strong>Chrome Android</strong> (atau browser Chromium
                lain) untuk hasil terbaik.
              </li>
              <li>
                Jalankan lewat <strong>HTTPS</strong> (GitHub Pages / Netlify)
                agar sensor & torch lebih diizinkan.
              </li>
              <li>
                Tekan <em>Mulai Kamera</em> → beri izin kamera → tekan
                <em>Aktifkan Mode Otomatis</em>.
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <!-- overlay untuk simulasi senter bila torch tidak didukung -->
    <div class="overlay-torch" id="overlayTorch"></div>
    <div class="overlay-text" id="overlayText" style="display: none">
      Senter (simulasi layar) aktif
    </div>

    <script>
      /* Smart Torch - Perceptron 2-input (single-file)
   - Auto mode requires user gesture: click Auto button
   - Tries to use videoTrack.applyConstraints({advanced:[{torch:true}]})
   - If torch unsupported, uses screen white overlay as fallback
*/

      const startBtn = document.getElementById("startBtn");
      const stopBtn = document.getElementById("stopBtn");
      const autoBtn = document.getElementById("autoBtn");
      const manualTorchBtn = document.getElementById("manualTorchBtn");
      const statusEl = document.getElementById("status");
      const logEl = document.getElementById("log");
      const video = document.getElementById("video");
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const brightBar = document.getElementById("brightBar");
      const motionBar = document.getElementById("motionBar");
      const brightVal = document.getElementById("brightVal");
      const motionVal = document.getElementById("motionVal");
      const brightThreshEl = document.getElementById("brightThresh");
      const motionThreshEl = document.getElementById("motionThresh");
      const capabilitiesEl = document.getElementById("capabilities");
      const overlay = document.getElementById("overlayTorch");
      const overlayText = document.getElementById("overlayText");

      let stream = null;
      let videoTrack = null;
      let prevFrame = null;
      let torchOn = false;
      let autoMode = false;
      let canTorch = false;
      let detecting = false;

      // util
      function log(msg) {
        const t = new Date().toLocaleTimeString();
        logEl.innerHTML =
          `<div style="margin-bottom:6px">[${t}] ${msg}</div>` +
          logEl.innerHTML;
      }
      function setStatus(s) {
        statusEl.textContent = "Status: " + s;
      }

      // start camera
      async function startCamera() {
        try {
          setStatus("Meminta akses kamera...");
          stream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: { ideal: "environment" },
              width: { ideal: 640 },
              height: { ideal: 480 },
            },
            audio: false,
          });
          video.srcObject = stream;
          videoTrack = stream.getVideoTracks()[0];
          video.play();
          stopBtn.disabled = false;
          autoBtn.disabled = false;
          manualTorchBtn.disabled = false;
          startBtn.disabled = true;
          setStatus("Kamera aktif");
          log("Kamera berhasil diakses");
          // check capabilities
          const caps = videoTrack.getCapabilities
            ? videoTrack.getCapabilities()
            : {};
          canTorch = !!(caps && caps.torch);
          capabilitiesEl.textContent =
            "Capabilities: " +
            (Object.keys(caps).length
              ? JSON.stringify(caps)
              : "tidak tersedia");
          log(
            "Torch support: " +
              (canTorch ? "YA" : "TIDAK (pakai simulasi layar)")
          );
          // start detection loop when video plays
          if (!detecting) {
            video.addEventListener("play", () => {
              detecting = true;
              detectLoop();
            });
          }
        } catch (err) {
          console.error(err);
          log("Gagal akses kamera: " + err.message);
          setStatus("Gagal akses kamera");
          alert(
            "Gagal mengakses kamera: " +
              err.message +
              "\nPastikan membuka via HTTPS dan beri izin kamera."
          );
        }
      }

      // stop camera
      function stopCamera() {
        if (stream) {
          stream.getTracks().forEach((t) => t.stop());
        }
        stream = null;
        videoTrack = null;
        startBtn.disabled = false;
        stopBtn.disabled = true;
        autoBtn.disabled = true;
        manualTorchBtn.disabled = true;
        setStatus("Kamera berhenti");
        detecting = false;
        // turn off torch overlay if any
        if (torchOn) turnTorch(false);
      }

      // manual toggle torch (user gesture)
      async function manualToggle() {
        if (!videoTrack) {
          alert("Kamera belum aktif");
          return;
        }
        if (!canTorch) {
          // use overlay instead
          turnOverlay(!torchOn);
          return;
        }
        try {
          torchOn = !torchOn;
          await videoTrack.applyConstraints({ advanced: [{ torch: torchOn }] });
          log("Manual toggle torch: " + (torchOn ? "ON" : "OFF"));
          setStatus("Torch " + (torchOn ? "ON" : "OFF"));
        } catch (e) {
          console.warn("Manual toggle failed", e);
          log("Gagal toggle torch: " + e.message);
          // fallback overlay
          turnOverlay(!torchOn);
        }
      }

      // helper to turn overlay (simulated screen flashlight)
      function turnOverlay(on) {
        if (on) {
          overlay.classList.add("on");
          overlayText.style.display = "block";
          torchOn = true;
          setStatus("Simulasi senter layar ON");
        } else {
          overlay.classList.remove("on");
          overlayText.style.display = "none";
          torchOn = false;
          setStatus("Simulasi senter layar OFF");
        }
      }

      // unified torch control (tries real torch, otherwise overlay)
      async function turnTorch(on) {
        if (!videoTrack) {
          // no camera: use overlay only
          turnOverlay(on);
          return;
        }
        if (canTorch) {
          try {
            await videoTrack.applyConstraints({ advanced: [{ torch: !!on }] });
            torchOn = !!on;
            setStatus("Torch " + (on ? "ON" : "OFF"));
            log("Torch (hardware) " + (on ? "diaktifkan" : "dimatikan"));
            // hide overlay if on
            if (!on) turnOverlay(false);
            return;
          } catch (e) {
            console.warn("applyConstraints torch error", e);
            log("applyConstraints error: " + e.message);
            // fallback to overlay
            turnOverlay(on);
          }
        } else {
          // fallback
          turnOverlay(on);
        }
      }

      // Auto mode activation (user gesture) - after click, autoMode=true and detection uses torch control
      async function enableAutoMode() {
        if (!videoTrack) {
          alert(
            "Mulai kamera dulu (Mulai Kamera) sebelum mengaktifkan mode otomatis."
          );
          return;
        }
        // This is the user gesture that may allow browser to permit torch operations
        autoMode = !autoMode;
        autoBtn.textContent = autoMode
          ? "Mode Otomatis: AKTIF"
          : "Aktifkan Mode Otomatis";
        autoBtn.style.opacity = autoMode ? "0.9" : "1";
        log("Auto mode " + (autoMode ? "diaktifkan" : "dimatikan"));
        setStatus("Auto mode " + (autoMode ? "AKTIF" : "MATI"));
        // If enabling auto mode, try an initial explicit small torch toggle (some browsers require toggle in user gesture)
        if (autoMode && canTorch) {
          try {
            // try briefly enable then disable to register permission
            await videoTrack.applyConstraints({ advanced: [{ torch: false }] });
            log("Prepared torch capability for auto mode");
          } catch (e) {
            console.warn("prepare torch failed", e);
          }
        }
      }

      // detection loop: compute brightness and motion, then decide using perceptron rule
      let prevImageData = null;
      async function detectLoop() {
        if (!detecting) return;
        if (video.readyState < 2) {
          requestAnimationFrame(detectLoop);
          return;
        }
        // set canvas small for speed
        const w = 320;
        const h = Math.round(
          video.videoHeight * (320 / video.videoWidth || 240)
        );
        canvas.width = w;
        canvas.height = h;
        ctx.drawImage(video, 0, 0, w, h);
        const frame = ctx.getImageData(0, 0, w, h);
        const data = frame.data;
        // brightness
        let sum = 0;
        for (let i = 0; i < data.length; i += 4 * 4) {
          // sample every 4th pixel for speed
          const r = data[i],
            g = data[i + 1],
            b = data[i + 2];
          sum += 0.299 * r + 0.587 * g + 0.114 * b;
        }
        const samples = data.length / (4 * 4);
        const avgBrightness = sum / samples;
        brightVal.textContent = Math.round(avgBrightness);
        const brightPct = Math.min(
          100,
          Math.max(0, (avgBrightness / 150) * 100)
        );
        brightBar.style.width = brightPct + "%";

        // motion detection
        let motionLevel = 0;
        if (prevImageData) {
          const prev = prevImageData.data;
          let diffSum = 0;
          for (let i = 0; i < data.length; i += 4 * 8) {
            // sparser sampling for speed
            const dr = Math.abs(data[i] - prev[i]);
            const dg = Math.abs(data[i + 1] - prev[i + 1]);
            const db = Math.abs(data[i + 2] - prev[i + 2]);
            diffSum += (dr + dg + db) / 3;
          }
          const count = data.length / (4 * 8);
          motionLevel = diffSum / count;
        }
        motionVal.textContent = motionLevel.toFixed(2);
        const motionPct = Math.min(100, Math.max(0, (motionLevel / 4) * 100));
        motionBar.style.width = motionPct + "%";

        // thresholds from UI
        const brightThresh = parseInt(brightThreshEl.value, 10) || 50;
        const motionThresh = parseFloat(motionThreshEl.value) || 8;

        // perceptron decision (two-input rule)
        const isDark = avgBrightness < brightThresh;
        const hasMotion = motionLevel > motionThresh;

        // Decision explanation
        // We want torch ON if:
        // 1) Gelap saja (isDark true)
        // OR
        // 2) Gelap + gerakan (isDark && hasMotion)
        // which effectively means ON when isDark is true (motion optional).
        const shouldTorch = isDark; // covers both conditions

        // apply: but only if autoMode is active (user asked)
        if (autoMode) {
          if (shouldTorch && !torchOn) {
            log(
              "Kondisi terpenuhi -> menyalakan senter (auto). isDark=" +
                isDark +
                " hasMotion=" +
                hasMotion
            );
            await turnTorch(true);
          } else if (!shouldTorch && torchOn) {
            log(
              "Kondisi tidak terpenuhi -> mematikan senter (auto). isDark=" +
                isDark +
                " hasMotion=" +
                hasMotion
            );
            await turnTorch(false);
          }
        }

        // store frame for next
        prevImageData = frame;
        requestAnimationFrame(detectLoop);
      }

      // event handlers
      startBtn.addEventListener("click", startCamera);
      stopBtn.addEventListener("click", stopCamera);
      autoBtn.addEventListener("click", enableAutoMode);
      manualTorchBtn.addEventListener("click", manualToggle);

      // initial UI state
      setStatus("Siap - tekan Mulai Kamera");
      log("Aplikasi siap. Tekan Mulai Kamera untuk memulai.");

      // cleanup on unload
      window.addEventListener("beforeunload", () => {
        if (stream) stream.getTracks().forEach((t) => t.stop());
      });
    </script>
  </body>
</html>
